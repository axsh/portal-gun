// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	model.proto

It has these top-level messages:
	VpnDriver
	SoftEtherParam
	NetworkDriver
	OpenVNetParam
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VpnDriver_Type int32

const (
	VpnDriver_NONE          VpnDriver_Type = 0
	VpnDriver_SOFTETHER_VPN VpnDriver_Type = 1
)

var VpnDriver_Type_name = map[int32]string{
	0: "NONE",
	1: "SOFTETHER_VPN",
}
var VpnDriver_Type_value = map[string]int32{
	"NONE":          0,
	"SOFTETHER_VPN": 1,
}

func (x VpnDriver_Type) String() string {
	return proto.EnumName(VpnDriver_Type_name, int32(x))
}
func (VpnDriver_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type NetworkDriver_Type int32

const (
	NetworkDriver_NONE     NetworkDriver_Type = 0
	NetworkDriver_OPENVNET NetworkDriver_Type = 1
)

var NetworkDriver_Type_name = map[int32]string{
	0: "NONE",
	1: "OPENVNET",
}
var NetworkDriver_Type_value = map[string]int32{
	"NONE":     0,
	"OPENVNET": 1,
}

func (x NetworkDriver_Type) String() string {
	return proto.EnumName(NetworkDriver_Type_name, int32(x))
}
func (NetworkDriver_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type VpnDriver struct {
	DriverType VpnDriver_Type `protobuf:"varint,1,opt,name=driver_type,json=driverType,enum=model.VpnDriver_Type" json:"driver_type,omitempty"`
	// Types that are valid to be assigned to ServerParams:
	//	*VpnDriver_Softehter
	ServerParams isVpnDriver_ServerParams `protobuf_oneof:"ServerParams"`
}

func (m *VpnDriver) Reset()                    { *m = VpnDriver{} }
func (m *VpnDriver) String() string            { return proto.CompactTextString(m) }
func (*VpnDriver) ProtoMessage()               {}
func (*VpnDriver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isVpnDriver_ServerParams interface {
	isVpnDriver_ServerParams()
}

type VpnDriver_Softehter struct {
	Softehter *SoftEtherParam `protobuf:"bytes,100,opt,name=softehter,oneof"`
}

func (*VpnDriver_Softehter) isVpnDriver_ServerParams() {}

func (m *VpnDriver) GetServerParams() isVpnDriver_ServerParams {
	if m != nil {
		return m.ServerParams
	}
	return nil
}

func (m *VpnDriver) GetDriverType() VpnDriver_Type {
	if m != nil {
		return m.DriverType
	}
	return VpnDriver_NONE
}

func (m *VpnDriver) GetSoftehter() *SoftEtherParam {
	if x, ok := m.GetServerParams().(*VpnDriver_Softehter); ok {
		return x.Softehter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VpnDriver) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VpnDriver_OneofMarshaler, _VpnDriver_OneofUnmarshaler, _VpnDriver_OneofSizer, []interface{}{
		(*VpnDriver_Softehter)(nil),
	}
}

func _VpnDriver_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VpnDriver)
	// ServerParams
	switch x := m.ServerParams.(type) {
	case *VpnDriver_Softehter:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Softehter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VpnDriver.ServerParams has unexpected type %T", x)
	}
	return nil
}

func _VpnDriver_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VpnDriver)
	switch tag {
	case 100: // ServerParams.softehter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SoftEtherParam)
		err := b.DecodeMessage(msg)
		m.ServerParams = &VpnDriver_Softehter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VpnDriver_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VpnDriver)
	// ServerParams
	switch x := m.ServerParams.(type) {
	case *VpnDriver_Softehter:
		s := proto.Size(x.Softehter)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SoftEtherParam struct {
	VirtualHub       string `protobuf:"bytes,1,opt,name=virtual_hub,json=virtualHub" json:"virtual_hub,omitempty"`
	Ipv4Network      string `protobuf:"bytes,2,opt,name=ipv4_network,json=ipv4Network" json:"ipv4_network,omitempty"`
	Ipv4BeginAddress uint32 `protobuf:"varint,3,opt,name=ipv4_begin_address,json=ipv4BeginAddress" json:"ipv4_begin_address,omitempty"`
	Ipv4EndAddress   uint32 `protobuf:"varint,4,opt,name=ipv4_end_address,json=ipv4EndAddress" json:"ipv4_end_address,omitempty"`
	TapId            string `protobuf:"bytes,5,opt,name=tap_id,json=tapId" json:"tap_id,omitempty"`
}

func (m *SoftEtherParam) Reset()                    { *m = SoftEtherParam{} }
func (m *SoftEtherParam) String() string            { return proto.CompactTextString(m) }
func (*SoftEtherParam) ProtoMessage()               {}
func (*SoftEtherParam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SoftEtherParam) GetVirtualHub() string {
	if m != nil {
		return m.VirtualHub
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4Network() string {
	if m != nil {
		return m.Ipv4Network
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4BeginAddress() uint32 {
	if m != nil {
		return m.Ipv4BeginAddress
	}
	return 0
}

func (m *SoftEtherParam) GetIpv4EndAddress() uint32 {
	if m != nil {
		return m.Ipv4EndAddress
	}
	return 0
}

func (m *SoftEtherParam) GetTapId() string {
	if m != nil {
		return m.TapId
	}
	return ""
}

type NetworkDriver struct {
	DriverType NetworkDriver_Type `protobuf:"varint,1,opt,name=driver_type,json=driverType,enum=model.NetworkDriver_Type" json:"driver_type,omitempty"`
	// Types that are valid to be assigned to InterfaceParams:
	//	*NetworkDriver_OpenvnetParam
	InterfaceParams isNetworkDriver_InterfaceParams `protobuf_oneof:"InterfaceParams"`
}

func (m *NetworkDriver) Reset()                    { *m = NetworkDriver{} }
func (m *NetworkDriver) String() string            { return proto.CompactTextString(m) }
func (*NetworkDriver) ProtoMessage()               {}
func (*NetworkDriver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isNetworkDriver_InterfaceParams interface {
	isNetworkDriver_InterfaceParams()
}

type NetworkDriver_OpenvnetParam struct {
	OpenvnetParam *OpenVNetParam `protobuf:"bytes,100,opt,name=openvnet_param,json=openvnetParam,oneof"`
}

func (*NetworkDriver_OpenvnetParam) isNetworkDriver_InterfaceParams() {}

func (m *NetworkDriver) GetInterfaceParams() isNetworkDriver_InterfaceParams {
	if m != nil {
		return m.InterfaceParams
	}
	return nil
}

func (m *NetworkDriver) GetDriverType() NetworkDriver_Type {
	if m != nil {
		return m.DriverType
	}
	return NetworkDriver_NONE
}

func (m *NetworkDriver) GetOpenvnetParam() *OpenVNetParam {
	if x, ok := m.GetInterfaceParams().(*NetworkDriver_OpenvnetParam); ok {
		return x.OpenvnetParam
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NetworkDriver) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NetworkDriver_OneofMarshaler, _NetworkDriver_OneofUnmarshaler, _NetworkDriver_OneofSizer, []interface{}{
		(*NetworkDriver_OpenvnetParam)(nil),
	}
}

func _NetworkDriver_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NetworkDriver)
	// InterfaceParams
	switch x := m.InterfaceParams.(type) {
	case *NetworkDriver_OpenvnetParam:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenvnetParam); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NetworkDriver.InterfaceParams has unexpected type %T", x)
	}
	return nil
}

func _NetworkDriver_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NetworkDriver)
	switch tag {
	case 100: // InterfaceParams.openvnet_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OpenVNetParam)
		err := b.DecodeMessage(msg)
		m.InterfaceParams = &NetworkDriver_OpenvnetParam{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NetworkDriver_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NetworkDriver)
	// InterfaceParams
	switch x := m.InterfaceParams.(type) {
	case *NetworkDriver_OpenvnetParam:
		s := proto.Size(x.OpenvnetParam)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OpenVNetParam struct {
	InterfaceId string                  `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	NetworkId   string                  `protobuf:"bytes,2,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
	Iplease     *OpenVNetParam_IpLease  `protobuf:"bytes,4,opt,name=iplease" json:"iplease,omitempty"`
	MacLease    *OpenVNetParam_MacLease `protobuf:"bytes,5,opt,name=mac_lease,json=macLease" json:"mac_lease,omitempty"`
}

func (m *OpenVNetParam) Reset()                    { *m = OpenVNetParam{} }
func (m *OpenVNetParam) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetParam) ProtoMessage()               {}
func (*OpenVNetParam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *OpenVNetParam) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *OpenVNetParam) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *OpenVNetParam) GetIplease() *OpenVNetParam_IpLease {
	if m != nil {
		return m.Iplease
	}
	return nil
}

func (m *OpenVNetParam) GetMacLease() *OpenVNetParam_MacLease {
	if m != nil {
		return m.MacLease
	}
	return nil
}

type OpenVNetParam_IpLease struct {
	Ipv4Address string `protobuf:"bytes,1,opt,name=ipv4_address,json=ipv4Address" json:"ipv4_address,omitempty"`
	MacLeaseId  string `protobuf:"bytes,2,opt,name=mac_lease_id,json=macLeaseId" json:"mac_lease_id,omitempty"`
	NetworkId   string `protobuf:"bytes,3,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
}

func (m *OpenVNetParam_IpLease) Reset()                    { *m = OpenVNetParam_IpLease{} }
func (m *OpenVNetParam_IpLease) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetParam_IpLease) ProtoMessage()               {}
func (*OpenVNetParam_IpLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *OpenVNetParam_IpLease) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *OpenVNetParam_IpLease) GetMacLeaseId() string {
	if m != nil {
		return m.MacLeaseId
	}
	return ""
}

func (m *OpenVNetParam_IpLease) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

type OpenVNetParam_MacLease struct {
	InterfaceId string `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	MacAddr     string `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
}

func (m *OpenVNetParam_MacLease) Reset()                    { *m = OpenVNetParam_MacLease{} }
func (m *OpenVNetParam_MacLease) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetParam_MacLease) ProtoMessage()               {}
func (*OpenVNetParam_MacLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

func (m *OpenVNetParam_MacLease) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *OpenVNetParam_MacLease) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*VpnDriver)(nil), "model.VpnDriver")
	proto.RegisterType((*SoftEtherParam)(nil), "model.SoftEtherParam")
	proto.RegisterType((*NetworkDriver)(nil), "model.NetworkDriver")
	proto.RegisterType((*OpenVNetParam)(nil), "model.OpenVNetParam")
	proto.RegisterType((*OpenVNetParam_IpLease)(nil), "model.OpenVNetParam.IpLease")
	proto.RegisterType((*OpenVNetParam_MacLease)(nil), "model.OpenVNetParam.MacLease")
	proto.RegisterEnum("model.VpnDriver_Type", VpnDriver_Type_name, VpnDriver_Type_value)
	proto.RegisterEnum("model.NetworkDriver_Type", NetworkDriver_Type_name, NetworkDriver_Type_value)
}

func init() { proto.RegisterFile("model.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 538 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x4f, 0x8f, 0xd2, 0x40,
	0x1c, 0xdd, 0xd9, 0x85, 0x05, 0x7e, 0x05, 0x64, 0x27, 0x6e, 0xc2, 0x6e, 0x5c, 0xc5, 0x7a, 0xe1,
	0xa0, 0x90, 0xac, 0xba, 0x87, 0x4d, 0x3c, 0x48, 0xac, 0x81, 0x44, 0x0b, 0x29, 0x84, 0x83, 0x97,
	0x66, 0x60, 0x06, 0x68, 0xa4, 0xed, 0x64, 0x3a, 0xa0, 0xfb, 0xa9, 0xfc, 0x04, 0x9e, 0xfc, 0x5e,
	0xc6, 0xcc, 0x74, 0x5a, 0x82, 0x70, 0xd8, 0xdb, 0xf4, 0xcd, 0x7b, 0xbf, 0x3f, 0xef, 0x4d, 0xc1,
	0x0a, 0x63, 0xca, 0xd6, 0x1d, 0x2e, 0x62, 0x19, 0xe3, 0xa2, 0xfe, 0xb0, 0x7f, 0x21, 0xa8, 0x4c,
	0x79, 0xf4, 0x49, 0x04, 0x5b, 0x26, 0xf0, 0x1d, 0x58, 0x54, 0x9f, 0x7c, 0xf9, 0xc0, 0x59, 0x13,
	0xb5, 0x50, 0xbb, 0x7e, 0x7b, 0xd9, 0x49, 0x75, 0x39, 0xad, 0x33, 0x79, 0xe0, 0xcc, 0x83, 0x94,
	0xa9, 0xce, 0xf8, 0x3d, 0x54, 0x92, 0x78, 0x21, 0xd9, 0x4a, 0x32, 0xd1, 0xa4, 0x2d, 0xd4, 0xb6,
	0x72, 0xd5, 0x38, 0x5e, 0x48, 0x47, 0xae, 0x98, 0x18, 0x11, 0x41, 0xc2, 0xfe, 0x89, 0xb7, 0x63,
	0xda, 0xaf, 0xa0, 0xa0, 0xe5, 0x65, 0x28, 0xb8, 0x43, 0xd7, 0x69, 0x9c, 0xe0, 0x0b, 0xa8, 0x8d,
	0x87, 0x9f, 0x27, 0xce, 0xa4, 0xef, 0x78, 0xfe, 0x74, 0xe4, 0x36, 0x50, 0xaf, 0x0e, 0xd5, 0x31,
	0x13, 0x5b, 0x53, 0x20, 0xb1, 0xff, 0x20, 0xa8, 0xef, 0x17, 0xc5, 0x2f, 0xc0, 0xda, 0x06, 0x42,
	0x6e, 0xc8, 0xda, 0x5f, 0x6d, 0x66, 0x7a, 0xec, 0x8a, 0x07, 0x06, 0xea, 0x6f, 0x66, 0xf8, 0x25,
	0x54, 0x03, 0xbe, 0x7d, 0xe7, 0x47, 0x4c, 0xfe, 0x88, 0xc5, 0xf7, 0xe6, 0xa9, 0x66, 0x58, 0x0a,
	0x73, 0x53, 0x08, 0xbf, 0x06, 0xac, 0x29, 0x33, 0xb6, 0x0c, 0x22, 0x9f, 0x50, 0x2a, 0x58, 0x92,
	0x34, 0xcf, 0x5a, 0xa8, 0x5d, 0xf3, 0x1a, 0xea, 0xa6, 0xa7, 0x2e, 0x3e, 0xa6, 0x38, 0x6e, 0x83,
	0xc6, 0x7c, 0x16, 0xd1, 0x9c, 0x5b, 0xd0, 0xdc, 0xba, 0xc2, 0x9d, 0x88, 0x66, 0xcc, 0x4b, 0x38,
	0x97, 0x84, 0xfb, 0x01, 0x6d, 0x16, 0x75, 0xd3, 0xa2, 0x24, 0x7c, 0x40, 0xed, 0xdf, 0x08, 0x6a,
	0xa6, 0xb5, 0xf1, 0xfe, 0xfe, 0x98, 0xf7, 0x57, 0xc6, 0xc5, 0x3d, 0xea, 0xa1, 0xff, 0x1f, 0xa0,
	0x1e, 0x73, 0x16, 0x6d, 0x23, 0x26, 0x7d, 0xae, 0x2c, 0x31, 0x21, 0x3c, 0x35, 0xf2, 0x21, 0x67,
	0xd1, 0xd4, 0x65, 0x32, 0xcb, 0xa0, 0x96, 0xb1, 0x35, 0x60, 0x3f, 0x3f, 0xc8, 0xa1, 0x0a, 0xe5,
	0xe1, 0xc8, 0x71, 0xa7, 0xae, 0x33, 0x69, 0xa0, 0xde, 0x05, 0x3c, 0x19, 0x44, 0x92, 0x89, 0x05,
	0x99, 0x33, 0x93, 0xc2, 0xdf, 0x53, 0xa8, 0xed, 0x55, 0xd5, 0x1e, 0x67, 0x24, 0xb5, 0x2e, 0x32,
	0x1e, 0x67, 0xd8, 0x80, 0xe2, 0x1b, 0x00, 0x93, 0x80, 0x22, 0xa4, 0x21, 0x54, 0x0c, 0x32, 0xa0,
	0xf8, 0x0e, 0x4a, 0x01, 0x5f, 0x33, 0x92, 0x30, 0xed, 0xa5, 0x75, 0xfb, 0xec, 0xd8, 0xf8, 0x9d,
	0x01, 0xff, 0xa2, 0x38, 0x5e, 0x46, 0xc6, 0xf7, 0x50, 0x09, 0xc9, 0xdc, 0x4f, 0x95, 0x45, 0xad,
	0xbc, 0x39, 0xaa, 0xfc, 0x4a, 0xe6, 0xa9, 0xb4, 0x1c, 0x9a, 0xd3, 0x75, 0x08, 0x25, 0x53, 0x2f,
	0x7f, 0x24, 0x59, 0x9e, 0x68, 0xf7, 0x48, 0xb2, 0x30, 0x5b, 0x50, 0xcd, 0x3b, 0xed, 0x56, 0x80,
	0xac, 0xda, 0xc1, 0x8a, 0x67, 0xff, 0xad, 0x78, 0xdd, 0x87, 0x72, 0x36, 0xc4, 0x63, 0x0c, 0xbb,
	0x02, 0x35, 0xa9, 0x9e, 0xc8, 0xf4, 0x2a, 0x85, 0x64, 0xae, 0xa6, 0xe9, 0xd9, 0xdf, 0x5a, 0xcb,
	0x40, 0xae, 0x36, 0xb3, 0xce, 0x3c, 0x0e, 0xbb, 0xe4, 0x67, 0xb2, 0xea, 0xf2, 0x58, 0x48, 0xb2,
	0x7e, 0xb3, 0xdc, 0x44, 0x5d, 0xbd, 0xfd, 0xec, 0x5c, 0xff, 0xea, 0x6f, 0xff, 0x05, 0x00, 0x00,
	0xff, 0xff, 0x63, 0x28, 0xd1, 0x3f, 0xf9, 0x03, 0x00, 0x00,
}
