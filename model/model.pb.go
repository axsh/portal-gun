// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	model.proto

It has these top-level messages:
	VpnServer
	SoftEtherParam
	Nic
	OpenVNetInterface
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VpnServer_Type int32

const (
	VpnServer_NONE          VpnServer_Type = 0
	VpnServer_SOFTETHER_VPN VpnServer_Type = 1
)

var VpnServer_Type_name = map[int32]string{
	0: "NONE",
	1: "SOFTETHER_VPN",
}
var VpnServer_Type_value = map[string]int32{
	"NONE":          0,
	"SOFTETHER_VPN": 1,
}

func (x VpnServer_Type) String() string {
	return proto.EnumName(VpnServer_Type_name, int32(x))
}
func (VpnServer_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Nic_Type int32

const (
	Nic_NONE     Nic_Type = 0
	Nic_OPENVNET Nic_Type = 1
)

var Nic_Type_name = map[int32]string{
	0: "NONE",
	1: "OPENVNET",
}
var Nic_Type_value = map[string]int32{
	"NONE":     0,
	"OPENVNET": 1,
}

func (x Nic_Type) String() string {
	return proto.EnumName(Nic_Type_name, int32(x))
}
func (Nic_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type VpnServer struct {
	DriverType VpnServer_Type `protobuf:"varint,1,opt,name=driver_type,json=driverType,enum=model.VpnServer_Type" json:"driver_type,omitempty"`
	// Types that are valid to be assigned to Param:
	//	*VpnServer_Softehter
	Param isVpnServer_Param `protobuf_oneof:"Param"`
}

func (m *VpnServer) Reset()                    { *m = VpnServer{} }
func (m *VpnServer) String() string            { return proto.CompactTextString(m) }
func (*VpnServer) ProtoMessage()               {}
func (*VpnServer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isVpnServer_Param interface {
	isVpnServer_Param()
}

type VpnServer_Softehter struct {
	Softehter *SoftEtherParam `protobuf:"bytes,100,opt,name=softehter,oneof"`
}

func (*VpnServer_Softehter) isVpnServer_Param() {}

func (m *VpnServer) GetParam() isVpnServer_Param {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *VpnServer) GetDriverType() VpnServer_Type {
	if m != nil {
		return m.DriverType
	}
	return VpnServer_NONE
}

func (m *VpnServer) GetSoftehter() *SoftEtherParam {
	if x, ok := m.GetParam().(*VpnServer_Softehter); ok {
		return x.Softehter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VpnServer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VpnServer_OneofMarshaler, _VpnServer_OneofUnmarshaler, _VpnServer_OneofSizer, []interface{}{
		(*VpnServer_Softehter)(nil),
	}
}

func _VpnServer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VpnServer)
	// Param
	switch x := m.Param.(type) {
	case *VpnServer_Softehter:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Softehter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VpnServer.Param has unexpected type %T", x)
	}
	return nil
}

func _VpnServer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VpnServer)
	switch tag {
	case 100: // Param.softehter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SoftEtherParam)
		err := b.DecodeMessage(msg)
		m.Param = &VpnServer_Softehter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VpnServer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VpnServer)
	// Param
	switch x := m.Param.(type) {
	case *VpnServer_Softehter:
		s := proto.Size(x.Softehter)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SoftEtherParam struct {
	VirtualHub       string `protobuf:"bytes,1,opt,name=virtual_hub,json=virtualHub" json:"virtual_hub,omitempty"`
	Ipv4Network      string `protobuf:"bytes,2,opt,name=ipv4_network,json=ipv4Network" json:"ipv4_network,omitempty"`
	Ipv4BeginAddress uint32 `protobuf:"varint,3,opt,name=ipv4_begin_address,json=ipv4BeginAddress" json:"ipv4_begin_address,omitempty"`
	Ipv4EndAddress   uint32 `protobuf:"varint,4,opt,name=ipv4_end_address,json=ipv4EndAddress" json:"ipv4_end_address,omitempty"`
	TapId            string `protobuf:"bytes,5,opt,name=tap_id,json=tapId" json:"tap_id,omitempty"`
}

func (m *SoftEtherParam) Reset()                    { *m = SoftEtherParam{} }
func (m *SoftEtherParam) String() string            { return proto.CompactTextString(m) }
func (*SoftEtherParam) ProtoMessage()               {}
func (*SoftEtherParam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SoftEtherParam) GetVirtualHub() string {
	if m != nil {
		return m.VirtualHub
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4Network() string {
	if m != nil {
		return m.Ipv4Network
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4BeginAddress() uint32 {
	if m != nil {
		return m.Ipv4BeginAddress
	}
	return 0
}

func (m *SoftEtherParam) GetIpv4EndAddress() uint32 {
	if m != nil {
		return m.Ipv4EndAddress
	}
	return 0
}

func (m *SoftEtherParam) GetTapId() string {
	if m != nil {
		return m.TapId
	}
	return ""
}

type Nic struct {
	DriverType Nic_Type `protobuf:"varint,1,opt,name=driver_type,json=driverType,enum=model.Nic_Type" json:"driver_type,omitempty"`
	// Types that are valid to be assigned to InterfaceParams:
	//	*Nic_OpenvnetInterface
	InterfaceParams isNic_InterfaceParams `protobuf_oneof:"InterfaceParams"`
}

func (m *Nic) Reset()                    { *m = Nic{} }
func (m *Nic) String() string            { return proto.CompactTextString(m) }
func (*Nic) ProtoMessage()               {}
func (*Nic) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isNic_InterfaceParams interface {
	isNic_InterfaceParams()
}

type Nic_OpenvnetInterface struct {
	OpenvnetInterface *OpenVNetInterface `protobuf:"bytes,100,opt,name=openvnet_interface,json=openvnetInterface,oneof"`
}

func (*Nic_OpenvnetInterface) isNic_InterfaceParams() {}

func (m *Nic) GetInterfaceParams() isNic_InterfaceParams {
	if m != nil {
		return m.InterfaceParams
	}
	return nil
}

func (m *Nic) GetDriverType() Nic_Type {
	if m != nil {
		return m.DriverType
	}
	return Nic_NONE
}

func (m *Nic) GetOpenvnetInterface() *OpenVNetInterface {
	if x, ok := m.GetInterfaceParams().(*Nic_OpenvnetInterface); ok {
		return x.OpenvnetInterface
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Nic) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Nic_OneofMarshaler, _Nic_OneofUnmarshaler, _Nic_OneofSizer, []interface{}{
		(*Nic_OpenvnetInterface)(nil),
	}
}

func _Nic_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Nic)
	// InterfaceParams
	switch x := m.InterfaceParams.(type) {
	case *Nic_OpenvnetInterface:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenvnetInterface); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Nic.InterfaceParams has unexpected type %T", x)
	}
	return nil
}

func _Nic_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Nic)
	switch tag {
	case 100: // InterfaceParams.openvnet_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OpenVNetInterface)
		err := b.DecodeMessage(msg)
		m.InterfaceParams = &Nic_OpenvnetInterface{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Nic_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Nic)
	// InterfaceParams
	switch x := m.InterfaceParams.(type) {
	case *Nic_OpenvnetInterface:
		s := proto.Size(x.OpenvnetInterface)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OpenVNetInterface struct {
	InterfaceId string                      `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	NetworkId   string                      `protobuf:"bytes,2,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
	Iplease     *OpenVNetInterface_IpLease  `protobuf:"bytes,4,opt,name=iplease" json:"iplease,omitempty"`
	MacLease    *OpenVNetInterface_MacLease `protobuf:"bytes,5,opt,name=mac_lease,json=macLease" json:"mac_lease,omitempty"`
}

func (m *OpenVNetInterface) Reset()                    { *m = OpenVNetInterface{} }
func (m *OpenVNetInterface) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetInterface) ProtoMessage()               {}
func (*OpenVNetInterface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *OpenVNetInterface) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *OpenVNetInterface) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *OpenVNetInterface) GetIplease() *OpenVNetInterface_IpLease {
	if m != nil {
		return m.Iplease
	}
	return nil
}

func (m *OpenVNetInterface) GetMacLease() *OpenVNetInterface_MacLease {
	if m != nil {
		return m.MacLease
	}
	return nil
}

type OpenVNetInterface_IpLease struct {
	Ipv4Address string `protobuf:"bytes,1,opt,name=ipv4_address,json=ipv4Address" json:"ipv4_address,omitempty"`
	MacLeaseId  string `protobuf:"bytes,2,opt,name=mac_lease_id,json=macLeaseId" json:"mac_lease_id,omitempty"`
	NetworkId   string `protobuf:"bytes,3,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
}

func (m *OpenVNetInterface_IpLease) Reset()                    { *m = OpenVNetInterface_IpLease{} }
func (m *OpenVNetInterface_IpLease) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetInterface_IpLease) ProtoMessage()               {}
func (*OpenVNetInterface_IpLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *OpenVNetInterface_IpLease) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *OpenVNetInterface_IpLease) GetMacLeaseId() string {
	if m != nil {
		return m.MacLeaseId
	}
	return ""
}

func (m *OpenVNetInterface_IpLease) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

type OpenVNetInterface_MacLease struct {
	InterfaceId string `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	MacAddr     string `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
}

func (m *OpenVNetInterface_MacLease) Reset()                    { *m = OpenVNetInterface_MacLease{} }
func (m *OpenVNetInterface_MacLease) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetInterface_MacLease) ProtoMessage()               {}
func (*OpenVNetInterface_MacLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

func (m *OpenVNetInterface_MacLease) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *OpenVNetInterface_MacLease) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*VpnServer)(nil), "model.VpnServer")
	proto.RegisterType((*SoftEtherParam)(nil), "model.SoftEtherParam")
	proto.RegisterType((*Nic)(nil), "model.Nic")
	proto.RegisterType((*OpenVNetInterface)(nil), "model.OpenVNetInterface")
	proto.RegisterType((*OpenVNetInterface_IpLease)(nil), "model.OpenVNetInterface.IpLease")
	proto.RegisterType((*OpenVNetInterface_MacLease)(nil), "model.OpenVNetInterface.MacLease")
	proto.RegisterEnum("model.VpnServer_Type", VpnServer_Type_name, VpnServer_Type_value)
	proto.RegisterEnum("model.Nic_Type", Nic_Type_name, Nic_Type_value)
}

func init() { proto.RegisterFile("model.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 541 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xdf, 0x8e, 0xd2, 0x40,
	0x14, 0xc6, 0xb7, 0x02, 0x0b, 0x9c, 0xb2, 0x2c, 0x4c, 0xb2, 0x49, 0xdd, 0x44, 0xed, 0xd6, 0x1b,
	0x2e, 0x14, 0xcc, 0xfa, 0xe7, 0xc2, 0x0b, 0x13, 0x49, 0x6a, 0x68, 0xa2, 0x85, 0x14, 0xc2, 0x85,
	0x37, 0xcd, 0xd0, 0x39, 0x40, 0x23, 0x6d, 0x27, 0xd3, 0x01, 0xdd, 0x57, 0xf0, 0x49, 0x7c, 0x01,
	0x9f, 0xc0, 0x17, 0x33, 0x9d, 0xfe, 0x21, 0x8a, 0x9b, 0x78, 0xd7, 0xf9, 0xe6, 0xfb, 0xce, 0x9c,
	0xf3, 0x9b, 0x29, 0xe8, 0x51, 0xc2, 0x70, 0x37, 0xe4, 0x22, 0x91, 0x09, 0x69, 0xa8, 0x85, 0xf5,
	0x43, 0x83, 0xf6, 0x92, 0xc7, 0x73, 0x14, 0x07, 0x14, 0xe4, 0x0d, 0xe8, 0x4c, 0x84, 0x07, 0x14,
	0xbe, 0xbc, 0xe3, 0x68, 0x68, 0xa6, 0x36, 0xe8, 0xde, 0x5e, 0x0d, 0xf3, 0x5c, 0x65, 0x1b, 0x2e,
	0xee, 0x38, 0x7a, 0x90, 0x3b, 0xb3, 0x6f, 0xf2, 0x1a, 0xda, 0x69, 0xb2, 0x96, 0xb8, 0x95, 0x28,
	0x0c, 0x66, 0x6a, 0x03, 0xbd, 0x4a, 0xcd, 0x93, 0xb5, 0xb4, 0xe5, 0x16, 0xc5, 0x8c, 0x0a, 0x1a,
	0x4d, 0xce, 0xbc, 0xa3, 0xd3, 0x7a, 0x0a, 0x75, 0x15, 0x6f, 0x41, 0xdd, 0x9d, 0xba, 0x76, 0xef,
	0x8c, 0xf4, 0xe1, 0x62, 0x3e, 0xfd, 0xb0, 0xb0, 0x17, 0x13, 0xdb, 0xf3, 0x97, 0x33, 0xb7, 0xa7,
	0x8d, 0x9b, 0xd0, 0x50, 0x51, 0xeb, 0x97, 0x06, 0xdd, 0x3f, 0xab, 0x91, 0x27, 0xa0, 0x1f, 0x42,
	0x21, 0xf7, 0x74, 0xe7, 0x6f, 0xf7, 0x2b, 0xd5, 0x6f, 0xdb, 0x83, 0x42, 0x9a, 0xec, 0x57, 0xe4,
	0x06, 0x3a, 0x21, 0x3f, 0xbc, 0xf2, 0x63, 0x94, 0x5f, 0x13, 0xf1, 0xc5, 0x78, 0xa0, 0x1c, 0x7a,
	0xa6, 0xb9, 0xb9, 0x44, 0x9e, 0x01, 0x51, 0x96, 0x15, 0x6e, 0xc2, 0xd8, 0xa7, 0x8c, 0x09, 0x4c,
	0x53, 0xa3, 0x66, 0x6a, 0x83, 0x0b, 0xaf, 0x97, 0xed, 0x8c, 0xb3, 0x8d, 0xf7, 0xb9, 0x4e, 0x06,
	0xa0, 0x34, 0x1f, 0x63, 0x56, 0x79, 0xeb, 0xca, 0xdb, 0xcd, 0x74, 0x3b, 0x66, 0xa5, 0xf3, 0x0a,
	0xce, 0x25, 0xe5, 0x7e, 0xc8, 0x8c, 0x86, 0x3a, 0xb4, 0x21, 0x29, 0x77, 0x98, 0xf5, 0x53, 0x83,
	0x9a, 0x1b, 0x06, 0xe4, 0xc5, 0xbf, 0x50, 0x5f, 0x16, 0xd0, 0xdc, 0x30, 0x38, 0x85, 0xec, 0x00,
	0x49, 0x38, 0xc6, 0x87, 0x18, 0xa5, 0x1f, 0xc6, 0x12, 0xc5, 0x9a, 0x06, 0x58, 0xd0, 0x36, 0x8a,
	0xe0, 0x94, 0x63, 0xbc, 0x74, 0x51, 0x3a, 0xe5, 0xfe, 0xe4, 0xcc, 0xeb, 0x97, 0xa9, 0x4a, 0xb4,
	0x1e, 0x9f, 0x80, 0xef, 0x40, 0x6b, 0x3a, 0xb3, 0xdd, 0xa5, 0x6b, 0x2f, 0x7a, 0xda, 0xb8, 0x0f,
	0x97, 0x95, 0x59, 0x91, 0x4e, 0xad, 0xef, 0x35, 0xe8, 0x9f, 0x54, 0x57, 0x7c, 0xcb, 0x45, 0x36,
	0xaa, 0x56, 0xf0, 0x2d, 0x35, 0x87, 0x91, 0x47, 0x00, 0x05, 0xfd, 0xcc, 0x90, 0x5f, 0x40, 0xbb,
	0x50, 0x1c, 0x46, 0xde, 0x42, 0x33, 0xe4, 0x3b, 0xa4, 0x29, 0x2a, 0x8e, 0xfa, 0xad, 0x79, 0xdf,
	0x28, 0x43, 0x87, 0x7f, 0xcc, 0x7c, 0x5e, 0x19, 0x20, 0xef, 0xa0, 0x1d, 0xd1, 0xc0, 0xcf, 0xd3,
	0x0d, 0x95, 0xbe, 0xb9, 0x37, 0xfd, 0x89, 0x06, 0x79, 0xbc, 0x15, 0x15, 0x5f, 0xd7, 0x11, 0x34,
	0x8b, 0x9a, 0xd5, 0x43, 0x29, 0xef, 0x54, 0x3b, 0x3e, 0x94, 0xf2, 0x42, 0x4d, 0xe8, 0x54, 0xa7,
	0x1d, 0x47, 0x81, 0xb2, 0xda, 0xc9, 0xa8, 0xb5, 0xbf, 0x46, 0xbd, 0x9e, 0x40, 0xab, 0x6c, 0xe2,
	0x7f, 0xc0, 0x3d, 0x84, 0xac, 0x53, 0xd5, 0x51, 0x71, 0x56, 0x33, 0xa2, 0x41, 0xd6, 0xcd, 0xd8,
	0xfa, 0x6c, 0x6e, 0x42, 0xb9, 0xdd, 0xaf, 0x86, 0x41, 0x12, 0x8d, 0xe8, 0xb7, 0x74, 0x3b, 0xe2,
	0x89, 0x90, 0x74, 0xf7, 0x7c, 0xb3, 0x8f, 0x47, 0x8a, 0xc0, 0xea, 0x5c, 0xfd, 0xe7, 0x2f, 0x7f,
	0x07, 0x00, 0x00, 0xff, 0xff, 0x96, 0x74, 0x79, 0x78, 0xf6, 0x03, 0x00, 0x00,
}
