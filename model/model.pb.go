// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	model.proto

It has these top-level messages:
	VpnDriver
	VpnServer
	SoftEtherParam
	Interface
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VpnDriver_Driver int32

const (
	VpnDriver_NONE          VpnDriver_Driver = 0
	VpnDriver_SOFTETHER_VPN VpnDriver_Driver = 1
)

var VpnDriver_Driver_name = map[int32]string{
	0: "NONE",
	1: "SOFTETHER_VPN",
}
var VpnDriver_Driver_value = map[string]int32{
	"NONE":          0,
	"SOFTETHER_VPN": 1,
}

func (x VpnDriver_Driver) String() string {
	return proto.EnumName(VpnDriver_Driver_name, int32(x))
}
func (VpnDriver_Driver) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type VpnDriver struct {
}

func (m *VpnDriver) Reset()                    { *m = VpnDriver{} }
func (m *VpnDriver) String() string            { return proto.CompactTextString(m) }
func (*VpnDriver) ProtoMessage()               {}
func (*VpnDriver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// vpn manager messgage
type VpnServer struct {
	Driver *VpnDriver `protobuf:"bytes,1,opt,name=driver" json:"driver,omitempty"`
	// Types that are valid to be assigned to Param:
	//	*VpnServer_Softehter
	Param isVpnServer_Param `protobuf_oneof:"Param"`
}

func (m *VpnServer) Reset()                    { *m = VpnServer{} }
func (m *VpnServer) String() string            { return proto.CompactTextString(m) }
func (*VpnServer) ProtoMessage()               {}
func (*VpnServer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isVpnServer_Param interface {
	isVpnServer_Param()
}

type VpnServer_Softehter struct {
	Softehter *SoftEtherParam `protobuf:"bytes,100,opt,name=softehter,oneof"`
}

func (*VpnServer_Softehter) isVpnServer_Param() {}

func (m *VpnServer) GetParam() isVpnServer_Param {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *VpnServer) GetDriver() *VpnDriver {
	if m != nil {
		return m.Driver
	}
	return nil
}

func (m *VpnServer) GetSoftehter() *SoftEtherParam {
	if x, ok := m.GetParam().(*VpnServer_Softehter); ok {
		return x.Softehter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VpnServer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VpnServer_OneofMarshaler, _VpnServer_OneofUnmarshaler, _VpnServer_OneofSizer, []interface{}{
		(*VpnServer_Softehter)(nil),
	}
}

func _VpnServer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VpnServer)
	// Param
	switch x := m.Param.(type) {
	case *VpnServer_Softehter:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Softehter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VpnServer.Param has unexpected type %T", x)
	}
	return nil
}

func _VpnServer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VpnServer)
	switch tag {
	case 100: // Param.softehter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SoftEtherParam)
		err := b.DecodeMessage(msg)
		m.Param = &VpnServer_Softehter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VpnServer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VpnServer)
	// Param
	switch x := m.Param.(type) {
	case *VpnServer_Softehter:
		s := proto.Size(x.Softehter)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SoftEtherParam struct {
	VirtualHub       string `protobuf:"bytes,1,opt,name=virtual_hub,json=virtualHub" json:"virtual_hub,omitempty"`
	Ipv4Network      string `protobuf:"bytes,2,opt,name=ipv4_network,json=ipv4Network" json:"ipv4_network,omitempty"`
	Ipv4BeginAddress uint32 `protobuf:"varint,3,opt,name=ipv4_begin_address,json=ipv4BeginAddress" json:"ipv4_begin_address,omitempty"`
	Ipv4EndAddress   uint32 `protobuf:"varint,4,opt,name=ipv4_end_address,json=ipv4EndAddress" json:"ipv4_end_address,omitempty"`
	TapId            string `protobuf:"bytes,5,opt,name=tap_id,json=tapId" json:"tap_id,omitempty"`
}

func (m *SoftEtherParam) Reset()                    { *m = SoftEtherParam{} }
func (m *SoftEtherParam) String() string            { return proto.CompactTextString(m) }
func (*SoftEtherParam) ProtoMessage()               {}
func (*SoftEtherParam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SoftEtherParam) GetVirtualHub() string {
	if m != nil {
		return m.VirtualHub
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4Network() string {
	if m != nil {
		return m.Ipv4Network
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4BeginAddress() uint32 {
	if m != nil {
		return m.Ipv4BeginAddress
	}
	return 0
}

func (m *SoftEtherParam) GetIpv4EndAddress() uint32 {
	if m != nil {
		return m.Ipv4EndAddress
	}
	return 0
}

func (m *SoftEtherParam) GetTapId() string {
	if m != nil {
		return m.TapId
	}
	return ""
}

// network manage message
type Interface struct {
	InterfaceId string              `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	NetworkId   string              `protobuf:"bytes,2,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
	Iplease     *Interface_IpLease  `protobuf:"bytes,4,opt,name=iplease" json:"iplease,omitempty"`
	MacLease    *Interface_MacLease `protobuf:"bytes,5,opt,name=mac_lease,json=macLease" json:"mac_lease,omitempty"`
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (m *Interface) String() string            { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Interface) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *Interface) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *Interface) GetIplease() *Interface_IpLease {
	if m != nil {
		return m.Iplease
	}
	return nil
}

func (m *Interface) GetMacLease() *Interface_MacLease {
	if m != nil {
		return m.MacLease
	}
	return nil
}

type Interface_IpLease struct {
	Ipv4Address string `protobuf:"bytes,1,opt,name=ipv4_address,json=ipv4Address" json:"ipv4_address,omitempty"`
	MacLeaseId  string `protobuf:"bytes,2,opt,name=mac_lease_id,json=macLeaseId" json:"mac_lease_id,omitempty"`
	NetworkId   string `protobuf:"bytes,3,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
}

func (m *Interface_IpLease) Reset()                    { *m = Interface_IpLease{} }
func (m *Interface_IpLease) String() string            { return proto.CompactTextString(m) }
func (*Interface_IpLease) ProtoMessage()               {}
func (*Interface_IpLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *Interface_IpLease) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *Interface_IpLease) GetMacLeaseId() string {
	if m != nil {
		return m.MacLeaseId
	}
	return ""
}

func (m *Interface_IpLease) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

type Interface_MacLease struct {
	InterfaceId string `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	MacAddr     string `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
}

func (m *Interface_MacLease) Reset()                    { *m = Interface_MacLease{} }
func (m *Interface_MacLease) String() string            { return proto.CompactTextString(m) }
func (*Interface_MacLease) ProtoMessage()               {}
func (*Interface_MacLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

func (m *Interface_MacLease) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *Interface_MacLease) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*VpnDriver)(nil), "model.VpnDriver")
	proto.RegisterType((*VpnServer)(nil), "model.VpnServer")
	proto.RegisterType((*SoftEtherParam)(nil), "model.SoftEtherParam")
	proto.RegisterType((*Interface)(nil), "model.Interface")
	proto.RegisterType((*Interface_IpLease)(nil), "model.Interface.IpLease")
	proto.RegisterType((*Interface_MacLease)(nil), "model.Interface.MacLease")
	proto.RegisterEnum("model.VpnDriver_Driver", VpnDriver_Driver_name, VpnDriver_Driver_value)
}

func init() { proto.RegisterFile("model.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0x4d, 0x6b, 0xdb, 0x40,
	0x10, 0x86, 0xa3, 0x24, 0xb2, 0xad, 0x51, 0x12, 0xdc, 0x85, 0x80, 0x12, 0xfa, 0xe1, 0x0a, 0x0a,
	0x3e, 0x14, 0x1b, 0xdc, 0x8f, 0x7b, 0x4d, 0x55, 0x2c, 0x68, 0x9d, 0x20, 0x87, 0x1c, 0x7a, 0x11,
	0x2b, 0xed, 0x3a, 0x12, 0xb5, 0x3e, 0x58, 0xad, 0xdc, 0xfe, 0xbf, 0xfe, 0xa3, 0xfe, 0x82, 0xb2,
	0xa3, 0x5d, 0x99, 0x36, 0x97, 0xdc, 0xb4, 0xef, 0x3c, 0x33, 0xf3, 0xce, 0x0b, 0x02, 0xb7, 0xa8,
	0x18, 0xdf, 0xcd, 0x6a, 0x51, 0xc9, 0x8a, 0xd8, 0xf8, 0xf0, 0x17, 0xe0, 0xdc, 0xd7, 0xe5, 0x67,
	0x91, 0xef, 0xb9, 0xf0, 0xdf, 0xc0, 0xa0, 0xfb, 0x22, 0x23, 0x38, 0x5d, 0xdf, 0xac, 0x83, 0xf1,
	0x11, 0x79, 0x06, 0xe7, 0x9b, 0x9b, 0x2f, 0x77, 0xc1, 0xdd, 0x2a, 0x88, 0xe2, 0xfb, 0xdb, 0xf5,
	0xd8, 0xf2, 0x5b, 0xec, 0xd9, 0x70, 0xa1, 0xc8, 0x29, 0x0c, 0x18, 0xf6, 0x78, 0xd6, 0xc4, 0x9a,
	0xba, 0x8b, 0xf1, 0xac, 0xdb, 0xd2, 0x4f, 0x8d, 0x74, 0x9d, 0x7c, 0x00, 0xa7, 0xa9, 0xb6, 0x92,
	0x67, 0x92, 0x0b, 0x8f, 0x21, 0x7c, 0xa9, 0xe1, 0x4d, 0xb5, 0x95, 0x81, 0xcc, 0xb8, 0xb8, 0xa5,
	0x82, 0x16, 0xab, 0xa3, 0xe8, 0x40, 0x2e, 0x87, 0x60, 0xa3, 0xea, 0xff, 0xb6, 0xe0, 0xe2, 0x5f,
	0x90, 0xbc, 0x02, 0x77, 0x9f, 0x0b, 0xd9, 0xd2, 0x5d, 0x9c, 0xb5, 0x09, 0x3a, 0x70, 0x22, 0xd0,
	0xd2, 0xaa, 0x4d, 0xc8, 0x6b, 0x38, 0xcb, 0xeb, 0xfd, 0xfb, 0xb8, 0xe4, 0xf2, 0x67, 0x25, 0x7e,
	0x78, 0xc7, 0x48, 0xb8, 0x4a, 0x5b, 0x77, 0x12, 0x79, 0x0b, 0x04, 0x91, 0x84, 0x3f, 0xe4, 0x65,
	0x4c, 0x19, 0x13, 0xbc, 0x69, 0xbc, 0x93, 0x89, 0x35, 0x3d, 0x8f, 0xc6, 0xaa, 0xb2, 0x54, 0x85,
	0x4f, 0x9d, 0x4e, 0xa6, 0x80, 0x5a, 0xcc, 0x4b, 0xd6, 0xb3, 0xa7, 0xc8, 0x5e, 0x28, 0x3d, 0x28,
	0x99, 0x21, 0x2f, 0x61, 0x20, 0x69, 0x1d, 0xe7, 0xcc, 0xb3, 0x71, 0xa9, 0x2d, 0x69, 0x1d, 0x32,
	0xff, 0xcf, 0x31, 0x38, 0x61, 0x29, 0xb9, 0xd8, 0xd2, 0x94, 0xa3, 0x3f, 0xf3, 0x50, 0xa8, 0xa5,
	0xfd, 0x19, 0x2d, 0x64, 0xe4, 0x05, 0x80, 0x76, 0xaf, 0x80, 0xee, 0x00, 0x47, 0x2b, 0x21, 0x23,
	0x0b, 0x18, 0xe6, 0xf5, 0x8e, 0xd3, 0x86, 0xa3, 0x0f, 0x77, 0xe1, 0xe9, 0x4c, 0xfb, 0x25, 0xb3,
	0xb0, 0xfe, 0xaa, 0xea, 0x91, 0x01, 0xc9, 0x47, 0x70, 0x0a, 0x9a, 0xc6, 0x5d, 0x97, 0x8d, 0x5d,
	0x57, 0x8f, 0xba, 0xbe, 0xd1, 0xb4, 0x6b, 0x1b, 0x15, 0xfa, 0xeb, 0xba, 0x80, 0xa1, 0x9e, 0xd5,
	0x07, 0x6b, 0x32, 0xb0, 0x0e, 0xc1, 0x9a, 0x00, 0x26, 0x70, 0xd6, 0x6f, 0x39, 0x58, 0x07, 0x33,
	0xed, 0xd1, 0x69, 0x27, 0xff, 0x9d, 0x76, 0xbd, 0x82, 0x91, 0x31, 0xf1, 0x94, 0xa0, 0xae, 0x40,
	0x39, 0x45, 0x47, 0x7a, 0xd7, 0xb0, 0xa0, 0xa9, 0x72, 0xb3, 0x7c, 0xf9, 0xfd, 0xf9, 0x43, 0x2e,
	0xb3, 0x36, 0x99, 0xa5, 0x55, 0x31, 0xa7, 0xbf, 0x9a, 0x6c, 0xbe, 0xaf, 0xcb, 0xac, 0x4d, 0xe6,
	0x78, 0x75, 0x32, 0xc0, 0x7f, 0xe2, 0xdd, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa8, 0x0a, 0x7e,
	0x1f, 0x22, 0x03, 0x00, 0x00,
}
