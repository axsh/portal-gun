// Code generated by protoc-gen-go. DO NOT EDIT.
// source: driver.proto

/*
Package driver is a generated protocol buffer package.

It is generated from these files:
	driver.proto

It has these top-level messages:
	VpnDriver
	VpnServer
	SoftEtherParam
	NetworkDriver
	Nic
	OpenVNetInterface
*/
package driver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VpnDriver_Driver int32

const (
	VpnDriver_NONE          VpnDriver_Driver = 0
	VpnDriver_SOFTETHER_VPN VpnDriver_Driver = 1
)

var VpnDriver_Driver_name = map[int32]string{
	0: "NONE",
	1: "SOFTETHER_VPN",
}
var VpnDriver_Driver_value = map[string]int32{
	"NONE":          0,
	"SOFTETHER_VPN": 1,
}

func (x VpnDriver_Driver) String() string {
	return proto.EnumName(VpnDriver_Driver_name, int32(x))
}
func (VpnDriver_Driver) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type NetworkDriver_Driver int32

const (
	NetworkDriver_NONE     NetworkDriver_Driver = 0
	NetworkDriver_OPENVNET NetworkDriver_Driver = 1
)

var NetworkDriver_Driver_name = map[int32]string{
	0: "NONE",
	1: "OPENVNET",
}
var NetworkDriver_Driver_value = map[string]int32{
	"NONE":     0,
	"OPENVNET": 1,
}

func (x NetworkDriver_Driver) String() string {
	return proto.EnumName(NetworkDriver_Driver_name, int32(x))
}
func (NetworkDriver_Driver) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type VpnDriver struct {
}

func (m *VpnDriver) Reset()                    { *m = VpnDriver{} }
func (m *VpnDriver) String() string            { return proto.CompactTextString(m) }
func (*VpnDriver) ProtoMessage()               {}
func (*VpnDriver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// vpn manager messgage
type VpnServer struct {
	Driver *VpnDriver `protobuf:"bytes,1,opt,name=driver" json:"driver,omitempty"`
	// Types that are valid to be assigned to Param:
	//	*VpnServer_Softehter
	Param isVpnServer_Param `protobuf_oneof:"Param"`
}

func (m *VpnServer) Reset()                    { *m = VpnServer{} }
func (m *VpnServer) String() string            { return proto.CompactTextString(m) }
func (*VpnServer) ProtoMessage()               {}
func (*VpnServer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isVpnServer_Param interface {
	isVpnServer_Param()
}

type VpnServer_Softehter struct {
	Softehter *SoftEtherParam `protobuf:"bytes,100,opt,name=softehter,oneof"`
}

func (*VpnServer_Softehter) isVpnServer_Param() {}

func (m *VpnServer) GetParam() isVpnServer_Param {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *VpnServer) GetDriver() *VpnDriver {
	if m != nil {
		return m.Driver
	}
	return nil
}

func (m *VpnServer) GetSoftehter() *SoftEtherParam {
	if x, ok := m.GetParam().(*VpnServer_Softehter); ok {
		return x.Softehter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VpnServer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VpnServer_OneofMarshaler, _VpnServer_OneofUnmarshaler, _VpnServer_OneofSizer, []interface{}{
		(*VpnServer_Softehter)(nil),
	}
}

func _VpnServer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VpnServer)
	// Param
	switch x := m.Param.(type) {
	case *VpnServer_Softehter:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Softehter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VpnServer.Param has unexpected type %T", x)
	}
	return nil
}

func _VpnServer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VpnServer)
	switch tag {
	case 100: // Param.softehter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SoftEtherParam)
		err := b.DecodeMessage(msg)
		m.Param = &VpnServer_Softehter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VpnServer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VpnServer)
	// Param
	switch x := m.Param.(type) {
	case *VpnServer_Softehter:
		s := proto.Size(x.Softehter)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SoftEtherParam struct {
	VirtualHub       string `protobuf:"bytes,1,opt,name=virtual_hub,json=virtualHub" json:"virtual_hub,omitempty"`
	Ipv4Network      string `protobuf:"bytes,2,opt,name=ipv4_network,json=ipv4Network" json:"ipv4_network,omitempty"`
	Ipv4BeginAddress uint32 `protobuf:"varint,3,opt,name=ipv4_begin_address,json=ipv4BeginAddress" json:"ipv4_begin_address,omitempty"`
	Ipv4EndAddress   uint32 `protobuf:"varint,4,opt,name=ipv4_end_address,json=ipv4EndAddress" json:"ipv4_end_address,omitempty"`
	TapId            string `protobuf:"bytes,5,opt,name=tap_id,json=tapId" json:"tap_id,omitempty"`
}

func (m *SoftEtherParam) Reset()                    { *m = SoftEtherParam{} }
func (m *SoftEtherParam) String() string            { return proto.CompactTextString(m) }
func (*SoftEtherParam) ProtoMessage()               {}
func (*SoftEtherParam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SoftEtherParam) GetVirtualHub() string {
	if m != nil {
		return m.VirtualHub
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4Network() string {
	if m != nil {
		return m.Ipv4Network
	}
	return ""
}

func (m *SoftEtherParam) GetIpv4BeginAddress() uint32 {
	if m != nil {
		return m.Ipv4BeginAddress
	}
	return 0
}

func (m *SoftEtherParam) GetIpv4EndAddress() uint32 {
	if m != nil {
		return m.Ipv4EndAddress
	}
	return 0
}

func (m *SoftEtherParam) GetTapId() string {
	if m != nil {
		return m.TapId
	}
	return ""
}

type NetworkDriver struct {
}

func (m *NetworkDriver) Reset()                    { *m = NetworkDriver{} }
func (m *NetworkDriver) String() string            { return proto.CompactTextString(m) }
func (*NetworkDriver) ProtoMessage()               {}
func (*NetworkDriver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Nic struct {
	Driver *NetworkDriver `protobuf:"bytes,1,opt,name=driver" json:"driver,omitempty"`
	// Types that are valid to be assigned to InterfaceParams:
	//	*Nic_OpenvnetInterface
	InterfaceParams isNic_InterfaceParams `protobuf_oneof:"InterfaceParams"`
}

func (m *Nic) Reset()                    { *m = Nic{} }
func (m *Nic) String() string            { return proto.CompactTextString(m) }
func (*Nic) ProtoMessage()               {}
func (*Nic) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isNic_InterfaceParams interface {
	isNic_InterfaceParams()
}

type Nic_OpenvnetInterface struct {
	OpenvnetInterface *OpenVNetInterface `protobuf:"bytes,100,opt,name=openvnet_interface,json=openvnetInterface,oneof"`
}

func (*Nic_OpenvnetInterface) isNic_InterfaceParams() {}

func (m *Nic) GetInterfaceParams() isNic_InterfaceParams {
	if m != nil {
		return m.InterfaceParams
	}
	return nil
}

func (m *Nic) GetDriver() *NetworkDriver {
	if m != nil {
		return m.Driver
	}
	return nil
}

func (m *Nic) GetOpenvnetInterface() *OpenVNetInterface {
	if x, ok := m.GetInterfaceParams().(*Nic_OpenvnetInterface); ok {
		return x.OpenvnetInterface
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Nic) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Nic_OneofMarshaler, _Nic_OneofUnmarshaler, _Nic_OneofSizer, []interface{}{
		(*Nic_OpenvnetInterface)(nil),
	}
}

func _Nic_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Nic)
	// InterfaceParams
	switch x := m.InterfaceParams.(type) {
	case *Nic_OpenvnetInterface:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenvnetInterface); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Nic.InterfaceParams has unexpected type %T", x)
	}
	return nil
}

func _Nic_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Nic)
	switch tag {
	case 100: // InterfaceParams.openvnet_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OpenVNetInterface)
		err := b.DecodeMessage(msg)
		m.InterfaceParams = &Nic_OpenvnetInterface{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Nic_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Nic)
	// InterfaceParams
	switch x := m.InterfaceParams.(type) {
	case *Nic_OpenvnetInterface:
		s := proto.Size(x.OpenvnetInterface)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// network manage message
type OpenVNetInterface struct {
	InterfaceId string                      `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	NetworkId   string                      `protobuf:"bytes,2,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
	Iplease     *OpenVNetInterface_IpLease  `protobuf:"bytes,4,opt,name=iplease" json:"iplease,omitempty"`
	MacLease    *OpenVNetInterface_MacLease `protobuf:"bytes,5,opt,name=mac_lease,json=macLease" json:"mac_lease,omitempty"`
}

func (m *OpenVNetInterface) Reset()                    { *m = OpenVNetInterface{} }
func (m *OpenVNetInterface) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetInterface) ProtoMessage()               {}
func (*OpenVNetInterface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *OpenVNetInterface) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *OpenVNetInterface) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *OpenVNetInterface) GetIplease() *OpenVNetInterface_IpLease {
	if m != nil {
		return m.Iplease
	}
	return nil
}

func (m *OpenVNetInterface) GetMacLease() *OpenVNetInterface_MacLease {
	if m != nil {
		return m.MacLease
	}
	return nil
}

type OpenVNetInterface_IpLease struct {
	Ipv4Address string `protobuf:"bytes,1,opt,name=ipv4_address,json=ipv4Address" json:"ipv4_address,omitempty"`
	MacLeaseId  string `protobuf:"bytes,2,opt,name=mac_lease_id,json=macLeaseId" json:"mac_lease_id,omitempty"`
	NetworkId   string `protobuf:"bytes,3,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
}

func (m *OpenVNetInterface_IpLease) Reset()                    { *m = OpenVNetInterface_IpLease{} }
func (m *OpenVNetInterface_IpLease) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetInterface_IpLease) ProtoMessage()               {}
func (*OpenVNetInterface_IpLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *OpenVNetInterface_IpLease) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *OpenVNetInterface_IpLease) GetMacLeaseId() string {
	if m != nil {
		return m.MacLeaseId
	}
	return ""
}

func (m *OpenVNetInterface_IpLease) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

type OpenVNetInterface_MacLease struct {
	InterfaceId string `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	MacAddr     string `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
}

func (m *OpenVNetInterface_MacLease) Reset()                    { *m = OpenVNetInterface_MacLease{} }
func (m *OpenVNetInterface_MacLease) String() string            { return proto.CompactTextString(m) }
func (*OpenVNetInterface_MacLease) ProtoMessage()               {}
func (*OpenVNetInterface_MacLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 1} }

func (m *OpenVNetInterface_MacLease) GetInterfaceId() string {
	if m != nil {
		return m.InterfaceId
	}
	return ""
}

func (m *OpenVNetInterface_MacLease) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*VpnDriver)(nil), "driver.VpnDriver")
	proto.RegisterType((*VpnServer)(nil), "driver.VpnServer")
	proto.RegisterType((*SoftEtherParam)(nil), "driver.SoftEtherParam")
	proto.RegisterType((*NetworkDriver)(nil), "driver.NetworkDriver")
	proto.RegisterType((*Nic)(nil), "driver.Nic")
	proto.RegisterType((*OpenVNetInterface)(nil), "driver.OpenVNetInterface")
	proto.RegisterType((*OpenVNetInterface_IpLease)(nil), "driver.OpenVNetInterface.IpLease")
	proto.RegisterType((*OpenVNetInterface_MacLease)(nil), "driver.OpenVNetInterface.MacLease")
	proto.RegisterEnum("driver.VpnDriver_Driver", VpnDriver_Driver_name, VpnDriver_Driver_value)
	proto.RegisterEnum("driver.NetworkDriver_Driver", NetworkDriver_Driver_name, NetworkDriver_Driver_value)
}

func init() { proto.RegisterFile("driver.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 532 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0x5d, 0xe8, 0xfa, 0x75, 0xdb, 0x8e, 0xd6, 0xd2, 0x50, 0x37, 0x69, 0x5a, 0x17, 0x09, 0xa9,
	0x48, 0xd0, 0x8a, 0x82, 0x78, 0xe1, 0x01, 0x51, 0x11, 0xd4, 0x22, 0x48, 0xab, 0xb4, 0xea, 0x03,
	0x2f, 0x91, 0x93, 0xb8, 0x4b, 0xc4, 0xe2, 0x58, 0x8e, 0xdb, 0xf1, 0x23, 0x78, 0xe3, 0x27, 0xf1,
	0xc7, 0x90, 0x1d, 0x3b, 0xd5, 0x36, 0x26, 0xf1, 0xe6, 0x7b, 0x7c, 0xce, 0xfd, 0x38, 0xd7, 0x86,
	0x76, 0xc4, 0x93, 0x3d, 0xe1, 0x23, 0xc6, 0x33, 0x91, 0xa1, 0x5a, 0x11, 0xd9, 0x13, 0x68, 0x6e,
	0x18, 0xfd, 0x54, 0x04, 0xcf, 0xa1, 0x56, 0x9c, 0x50, 0x03, 0x8e, 0xdd, 0x85, 0xeb, 0x74, 0x8f,
	0x50, 0x0f, 0x3a, 0xab, 0xc5, 0xe7, 0xb5, 0xb3, 0x9e, 0x39, 0x9e, 0xbf, 0x59, 0xba, 0x5d, 0xcb,
	0xbe, 0x55, 0x9a, 0x15, 0xe1, 0x92, 0xf9, 0x02, 0x74, 0xaa, 0xbe, 0x35, 0xb0, 0x86, 0xad, 0x49,
	0x6f, 0xa4, 0xeb, 0x94, 0x69, 0x3d, 0x4d, 0x40, 0xef, 0xa0, 0x99, 0x67, 0x5b, 0x41, 0x62, 0x41,
	0x78, 0x3f, 0x52, 0xec, 0x67, 0x86, 0xbd, 0xca, 0xb6, 0xc2, 0x11, 0x31, 0xe1, 0x4b, 0xcc, 0x71,
	0x3a, 0x3b, 0xf2, 0x0e, 0xd4, 0x69, 0x1d, 0xaa, 0x0a, 0xb5, 0xff, 0x58, 0x70, 0x72, 0x97, 0x88,
	0x2e, 0xa1, 0xb5, 0x4f, 0xb8, 0xd8, 0xe1, 0x1b, 0x3f, 0xde, 0x05, 0xaa, 0x87, 0xa6, 0x07, 0x1a,
	0x9a, 0xed, 0x02, 0x74, 0x05, 0xed, 0x84, 0xed, 0xdf, 0xfa, 0x94, 0x88, 0xdb, 0x8c, 0xff, 0xe8,
	0x3f, 0x51, 0x8c, 0x96, 0xc4, 0xdc, 0x02, 0x42, 0x2f, 0x01, 0x29, 0x4a, 0x40, 0xae, 0x13, 0xea,
	0xe3, 0x28, 0xe2, 0x24, 0xcf, 0xfb, 0x95, 0x81, 0x35, 0xec, 0x78, 0x5d, 0x79, 0x33, 0x95, 0x17,
	0x1f, 0x0b, 0x1c, 0x0d, 0x41, 0x61, 0x3e, 0xa1, 0x51, 0xc9, 0x3d, 0x56, 0xdc, 0x13, 0x89, 0x3b,
	0x34, 0x32, 0xcc, 0x53, 0xa8, 0x09, 0xcc, 0xfc, 0x24, 0xea, 0x57, 0x55, 0xd1, 0xaa, 0xc0, 0x6c,
	0x1e, 0xd9, 0xaf, 0xa1, 0xa3, 0x2b, 0x6b, 0xdb, 0x07, 0xff, 0xb0, 0xbd, 0x0d, 0x8d, 0xc5, 0xd2,
	0x71, 0x37, 0xae, 0xb3, 0xee, 0x5a, 0xf6, 0x6f, 0x0b, 0x2a, 0x6e, 0x12, 0xa2, 0x57, 0xf7, 0xcc,
	0x3e, 0x35, 0xf6, 0xdd, 0x49, 0x58, 0x1a, 0xfe, 0x05, 0x50, 0xc6, 0x08, 0xdd, 0x53, 0x22, 0xfc,
	0x84, 0x0a, 0xc2, 0xb7, 0x38, 0x24, 0xda, 0xf9, 0x33, 0x23, 0x5d, 0x30, 0x42, 0x37, 0x2e, 0x11,
	0x73, 0x43, 0x98, 0x1d, 0x79, 0x3d, 0x23, 0x2b, 0xc1, 0x69, 0x0f, 0x9e, 0x96, 0x81, 0xb2, 0x3e,
	0xb7, 0x7f, 0x55, 0xa0, 0xf7, 0x40, 0xad, 0x0c, 0x37, 0x81, 0x9c, 0xdd, 0xd2, 0x86, 0x1b, 0x6c,
	0x1e, 0xa1, 0x0b, 0x00, 0xbd, 0x0e, 0x49, 0x28, 0x36, 0xd2, 0xd4, 0xc8, 0x3c, 0x42, 0xef, 0xa1,
	0x9e, 0xb0, 0x1b, 0x82, 0x73, 0xa2, 0x8c, 0x6d, 0x4d, 0xae, 0x1e, 0xed, 0x75, 0x34, 0x67, 0x5f,
	0x25, 0xd1, 0x33, 0x0a, 0xf4, 0x01, 0x9a, 0x29, 0x0e, 0xfd, 0x42, 0x5e, 0x55, 0x72, 0xfb, 0x71,
	0xf9, 0x37, 0x1c, 0x16, 0xfa, 0x46, 0xaa, 0x4f, 0xe7, 0x29, 0xd4, 0x75, 0xd2, 0xf2, 0xed, 0x98,
	0x35, 0x5b, 0x87, 0xb7, 0x63, 0x76, 0x3c, 0x80, 0x76, 0x59, 0xee, 0x30, 0x0c, 0x98, 0x6c, 0x0f,
	0x86, 0xad, 0xdc, 0x1b, 0xf6, 0x7c, 0x06, 0x0d, 0xd3, 0xc4, 0xff, 0x58, 0x77, 0x06, 0xb2, 0x53,
	0xd5, 0x91, 0xae, 0x55, 0x4f, 0x71, 0x28, 0xbb, 0x99, 0x5e, 0x7e, 0xbf, 0xb8, 0x4e, 0x44, 0xbc,
	0x0b, 0x46, 0x61, 0x96, 0x8e, 0xf1, 0xcf, 0x3c, 0x1e, 0xef, 0x19, 0x8d, 0x77, 0xc1, 0xb8, 0x18,
	0x3f, 0xa8, 0xa9, 0xaf, 0xff, 0xe6, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x57, 0x92, 0xc4, 0x7d,
	0x0a, 0x04, 0x00, 0x00,
}
